#include "api/signal.h"
#include "api/sys/poll.h"
#include "api/sys/socket.h"
#include "memory/memory.h"
#include "panic.h"
#include "socket.h"
#include "task.h"

static void unix_socket_destroy_inode(struct inode* inode) {
    struct unix_socket* socket = unix_socket_from_inode(inode);
    ring_buf_destroy(&socket->to_connector_buf);
    ring_buf_destroy(&socket->to_acceptor_buf);
    kfree(socket);
}

static int unix_socket_close(struct file* file) {
    struct unix_socket* socket = unix_socket_from_file(file);
    socket->is_open_for_writing_to_connector = false;
    socket->is_open_for_writing_to_acceptor = false;
    return 0;
}

static bool is_connector(struct file* file) {
    return unix_socket_from_file(file)->connector_file == file;
}

static bool is_open_for_reading(struct file* file) {
    struct unix_socket* socket = unix_socket_from_file(file);
    return is_connector(file) ? socket->is_open_for_writing_to_connector
                              : socket->is_open_for_writing_to_acceptor;
}

static struct ring_buf* buf_to_read(struct file* file) {
    struct unix_socket* socket = unix_socket_from_file(file);
    return is_connector(file) ? &socket->to_connector_buf
                              : &socket->to_acceptor_buf;
}

static struct ring_buf* buf_to_write(struct file* file) {
    struct unix_socket* socket = unix_socket_from_file(file);
    return is_connector(file) ? &socket->to_acceptor_buf
                              : &socket->to_connector_buf;
}

static bool is_readable(struct file* file) {
    if (!is_open_for_reading(file))
        return true;
    struct ring_buf* buf = buf_to_read(file);
    return !ring_buf_is_empty(buf);
}

static ssize_t unix_socket_pread(struct file* file, void* buffer, size_t count,
                                 uint64_t offset) {
    (void)offset;

    struct unix_socket* socket = unix_socket_from_file(file);
    if (!socket->is_connected)
        return -EINVAL;

    struct ring_buf* buf = buf_to_read(file);
    for (;;) {
        int rc = file_block(file, is_readable, 0);
        if (IS_ERR(rc))
            return rc;

        mutex_lock(&socket->lock);
        if (!ring_buf_is_empty(buf)) {
            ssize_t nread = ring_buf_read(buf, buffer, count);
            mutex_unlock(&socket->lock);
            return nread;
        }
        mutex_unlock(&socket->lock);

        if (!is_open_for_reading(file))
            return 0;
    }
}

static bool is_writable(struct file* file) {
    struct unix_socket* socket = unix_socket_from_file(file);
    if (is_connector(file)) {
        if (!socket->is_open_for_writing_to_acceptor)
            return false;
    } else if (!socket->is_open_for_writing_to_connector) {
        return true;
    }
    struct ring_buf* buf = buf_to_write(file);
    return !ring_buf_is_full(buf);
}

static ssize_t unix_socket_pwrite(struct file* file, const void* buffer,
                                  size_t count, uint64_t offset) {
    (void)offset;

    struct unix_socket* socket = unix_socket_from_file(file);
    if (!socket->is_connected)
        return -ENOTCONN;

    struct ring_buf* buf = buf_to_write(file);
    for (;;) {
        int rc = file_block(file, is_writable, 0);
        if (IS_ERR(rc))
            return rc;

        if (!is_connector(file) && !socket->is_open_for_writing_to_connector) {
            int rc = task_send_signal(current->tid, SIGPIPE, 0);
            if (IS_ERR(rc))
                return rc;
            return -EPIPE;
        }

        mutex_lock(&socket->lock);
        if (!ring_buf_is_full(buf)) {
            ssize_t nwritten = ring_buf_write(buf, buffer, count);
            mutex_unlock(&socket->lock);
            return nwritten;
        }
        mutex_unlock(&socket->lock);
    }
}

static short unix_socket_poll(struct file* file, short events) {
    struct unix_socket* socket = unix_socket_from_file(file);
    short revents = 0;
    if (events & POLLIN) {
        bool can_read =
            socket->is_connected ? is_readable(file) : socket->num_pending > 0;
        if (can_read)
            revents |= POLLIN;
    }
    if (events & POLLOUT) {
        bool can_write = socket->is_connected && is_writable(file);
        if (can_write)
            revents |= POLLOUT;
    }
    if ((events & POLLHUP) && !socket->is_open_for_writing_to_connector &&
        !socket->is_open_for_writing_to_acceptor)
        revents |= POLLHUP;
    return revents;
}

struct unix_socket* unix_socket_create(void) {
    struct unix_socket* socket = kmalloc(sizeof(struct unix_socket));
    if (!socket)
        return ERR_PTR(-ENOMEM);
    *socket = (struct unix_socket){0};

    struct inode* inode = &socket->inode;
    inode->vm_obj = INODE_VM_OBJ_INIT;
    static const struct file_ops fops = {
        .destroy_inode = unix_socket_destroy_inode,
        .close = unix_socket_close,
        .pread = unix_socket_pread,
        .pwrite = unix_socket_pwrite,
        .poll = unix_socket_poll,
    };
    inode->fops = &fops;
    inode->mode = S_IFSOCK;

    socket->state = SOCKET_STATE_OPENED;
    socket->is_open_for_writing_to_connector = true;
    socket->is_open_for_writing_to_acceptor = true;

    int rc = ring_buf_init(&socket->to_acceptor_buf, PAGE_SIZE);
    if (IS_ERR(rc)) {
        kfree(socket);
        return ERR_PTR(rc);
    }
    rc = ring_buf_init(&socket->to_connector_buf, PAGE_SIZE);
    if (IS_ERR(rc)) {
        ring_buf_destroy(&socket->to_acceptor_buf);
        kfree(socket);
        return ERR_PTR(rc);
    }

    return socket;
}

int unix_socket_bind(struct unix_socket* socket, struct inode* addr_inode) {
    mutex_lock(&socket->lock);
    if (socket->is_bound) {
        mutex_unlock(&socket->lock);
        return -EINVAL;
    }
    addr_inode->bound_socket = socket;
    socket->is_bound = true;
    mutex_unlock(&socket->lock);
    return 0;
}

int unix_socket_listen(struct unix_socket* socket, int backlog) {
    mutex_lock(&socket->lock);
    switch (socket->state) {
    case SOCKET_STATE_OPENED:
    case SOCKET_STATE_LISTENING:
        break;
    default:
        mutex_unlock(&socket->lock);
        return -EINVAL;
    }
    if (!socket->is_bound) {
        mutex_unlock(&socket->lock);
        return -EINVAL;
    }
    socket->backlog = backlog;
    if (socket->state == SOCKET_STATE_OPENED)
        socket->state = SOCKET_STATE_LISTENING;
    mutex_unlock(&socket->lock);
    return 0;
}

static bool is_acceptable(struct file* file) {
    return unix_socket_from_file(file)->num_pending > 0;
}

struct unix_socket* unix_socket_accept(struct file* file) {
    if (!S_ISSOCK(file->inode->mode))
        return ERR_PTR(-ENOTSOCK);

    struct unix_socket* listener = unix_socket_from_file(file);

    mutex_lock(&listener->lock);
    bool is_listening = listener->state == SOCKET_STATE_LISTENING;
    mutex_unlock(&listener->lock);
    if (!is_listening)
        return ERR_PTR(-EINVAL);

    for (;;) {
        int rc = file_block(file, is_acceptable, 0);
        if (IS_ERR(rc))
            return ERR_PTR(rc);

        mutex_lock(&listener->lock);

        struct unix_socket* connector = listener->next;
        if (connector) {
            listener->next = connector->next;
            --listener->num_pending;
        }

        mutex_unlock(&listener->lock);

        if (!connector)
            continue;

        mutex_lock(&connector->lock);
        ASSERT(connector->state == SOCKET_STATE_PENDING);
        connector->state = SOCKET_STATE_CONNECTED;
        connector->is_connected = true;
        mutex_unlock(&connector->lock);
        return connector;
    }
}

static bool is_connectable(struct file* file) {
    return unix_socket_from_file(file)->is_connected;
}

int unix_socket_connect(struct file* file, struct inode* addr_inode) {
    if (!S_ISSOCK(file->inode->mode))
        return -ENOTSOCK;

    struct unix_socket* listener = addr_inode->bound_socket;
    if (!listener)
        return -ECONNREFUSED;

    struct unix_socket* connector = unix_socket_from_file(file);
    mutex_lock(&connector->lock);

    switch (connector->state) {
    case SOCKET_STATE_LISTENING:
        mutex_unlock(&connector->lock);
        return -EINVAL;
    case SOCKET_STATE_PENDING:
    case SOCKET_STATE_CONNECTED:
        mutex_unlock(&connector->lock);
        return -EISCONN;
    default:
        break;
    }

    mutex_lock(&listener->lock);

    if (listener->state != SOCKET_STATE_LISTENING ||
        listener->num_pending >= (size_t)listener->backlog) {
        mutex_unlock(&listener->lock);
        mutex_unlock(&connector->lock);
        return -ECONNREFUSED;
    }

    ++listener->num_pending;

    connector->connector_file = file;
    connector->state = SOCKET_STATE_PENDING;
    connector->next = NULL;

    inode_ref(&connector->inode);

    if (listener->next) {
        struct unix_socket* it = listener->next;
        while (it->next)
            it = it->next;
        it->next = connector;
    } else {
        listener->next = connector;
    }

    mutex_unlock(&listener->lock);
    mutex_unlock(&connector->lock);

    return file_block(file, is_connectable, 0);
}

int unix_socket_shutdown(struct file* file, int how) {
    if (!S_ISSOCK(file->inode->mode))
        return -ENOTSOCK;

    switch (how) {
    case SHUT_RD:
    case SHUT_WR:
    case SHUT_RDWR:
        break;
    default:
        return -EINVAL;
    }

    bool shut_read = how == SHUT_RD || how == SHUT_RDWR;
    bool shut_write = how == SHUT_WR || how == SHUT_RDWR;
    bool conn = is_connector(file);
    struct unix_socket* socket = unix_socket_from_file(file);
    if ((conn && shut_read) || (!conn && shut_write))
        socket->is_open_for_writing_to_connector = false;
    if ((conn && shut_write) || (!conn && shut_read))
        socket->is_open_for_writing_to_acceptor = false;

    return 0;
}
